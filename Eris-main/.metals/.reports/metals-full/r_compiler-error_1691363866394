scala.reflect.internal.FatalError: 
  unexpected tree: class scala.reflect.internal.Trees$Template
Scene(400, 450) {
  def <init>(): <$anon: scalafx.scene.Scene> = {
    super.<init>();
    ()
  };
  private[this] var userConfig: Array[String] = Array[String]();
  private[this] var connectionProfile: scala.io.BufferedSource = Source.fromFile("config.txt");
  connectionProfile.getLines.foreach(((line: String) => userConfig = userConfig.$colon$plus(line.toString())));
  connectionProfile.close;
  private[this] var connector: Connector = Connector(userConfig(0), userConfig(1), userConfig(2), userConfig(3));
  private[this] var conn: java.sql.Connection = connector.getConnection();
  private[this] var st: java.sql.Statement = conn.createStatement();
  private[this] var ctx: Database.InstanceSchema = Database.loadSchema_for_gui(conn);
  private[this] var ctx1: Database.InstanceSchema = Database.loadSchema(conn);
  private[this] val tabpane: scalafx.scene.control.TabPane = new TabPane();
  private[this] val tab1: scalafx.scene.control.Tab = new Tab();
  tab1.text = "General";
  private[this] val tab2: scalafx.scene.control.Tab = new Tab();
  tab2.text = "Grund Truth";
  private[this] val tab3: scalafx.scene.control.Tab = new Tab();
  tab3.text = "Query Input";
  private[this] val tab4: scalafx.scene.control.Tab = new Tab();
  tab4.text = "Help";
  private[this] val tabs: IndexedSeq[javafx.scene.control.Tab] = IndexedSeq(tab1.delegate, tab2.delegate, tab3.delegate, tab4.delegate);
  private[this] val label: scalafx.scene.control.Label = new Label("Which Encoding would you prefer?");
  private[this] val rbn1: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("NF2_SparseV") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        enc = "nf2_sparsev";
        encoding = Encoding.encoder_to_use(enc)
      })
    };
    new $anon()
  };
  private[this] val rbn2: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("Partitioning") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        enc = "partitioning";
        encoding = Encoding.encoder_to_use(enc)
      })
    };
    new $anon()
  };
  private[this] val toggol1: scalafx.scene.control.ToggleGroup = new ToggleGroup();
  toggol1.toggles = List(rbn1, rbn2);
  private[this] val label1: scalafx.scene.control.Label = {
    final class $anon extends Label("Variable Generation") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      <empty>
    };
    new $anon()
  };
  private[this] val rbn3: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("V+X") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => flagV = "true")
    };
    new $anon()
  };
  private[this] val rbn4: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("V.(1+X)") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => flagV = "false")
    };
    new $anon()
  };
  private[this] val toggol2: scalafx.scene.control.ToggleGroup = new ToggleGroup();
  toggol2.toggles = List(rbn3, rbn4);
  private[this] val label2: scalafx.scene.control.Label = {
    final class $anon extends Label("Do you want to consider NULL in cost function?") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      <empty>
    };
    new $anon()
  };
  private[this] val rbn_null: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("Yes") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => flag_null = "true")
    };
    new $anon()
  };
  private[this] val rbn_not_null: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("No") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => flag_null = "false")
    };
    new $anon()
  };
  private[this] val toggol3: scalafx.scene.control.ToggleGroup = new ToggleGroup();
  toggol3.toggles = List(rbn_null, rbn_not_null);
  private[this] val label3: scalafx.scene.control.Label = {
    final class $anon extends Label("Cost functions") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      <empty>
    };
    new $anon()
  };
  private[this] val rbn_s_error: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("Average Square Error (ASE)") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        flag_error = "ASE";
        print(flag_error)
      })
    };
    new $anon()
  };
  private[this] val rbn_a_error: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("Average Absolute Error (AAE)") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        flag_error = "AAE";
        print(flag_error)
      })
    };
    new $anon()
  };
  private[this] val rbn_value_interval: scalafx.scene.control.RadioButton = {
    final class $anon extends RadioButton("Error with Variable Constraints") {
      def <init>(): <$anon: scalafx.scene.control.RadioButton> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        flag_error = "Value_Interval";
        print(flag_error)
      })
    };
    new $anon()
  };
  private[this] val toggol4: scalafx.scene.control.ToggleGroup = new ToggleGroup();
  toggol4.toggles = List(rbn_s_error, rbn_a_error, rbn_value_interval);
  private def createLoadingTask(): scalafx.concurrent.Task[Unit] = Task({
    ctx1.withFilter(((check$ifrefutable$1: (String, Database.Schema)) => check$ifrefutable$1: @scala.unchecked match {
  case scala.Tuple2((k @ _), (v @ _)) => true
  case _ => false
})).foreach(((x$2: (String, Database.Schema)) => x$2: @scala.unchecked match {
      case scala.Tuple2((k @ _), (v @ _)) => Loader.load(connector, k.toLowerCase(), encoding, false, flagV.toBoolean)
    }));
    Thread.sleep(10000)
  });
  private def showCompletedMessage(): scalafx.scene.control.Label = {
    val com: scalafx.scene.control.Label = new Label("Completed!");
    com
  };
  private[this] val progressBar: scalafx.scene.control.ProgressBar = {
    final class $anon extends ProgressBar {
      def <init>(): <$anon: scalafx.scene.control.ProgressBar> = {
        super.<init>();
        ()
      };
      prefWidth = 200
    };
    new $anon()
  };
  private[this] val loadingLabel: scalafx.scene.control.Label = {
    final class $anon extends Label("Loading...") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      visible = false
    };
    new $anon()
  };
  private[this] val completed: scalafx.scene.control.Label = {
    final class $anon extends Label("Completed!!") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      visible = false
    };
    new $anon()
  };
  private[this] val tab1hbox: scalafx.scene.layout.HBox = {
    final class $anon extends HBox {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      spacing = 20;
      children = Seq(loadingLabel, completed)
    };
    new $anon()
  };
  private[this] val loadbtn: scalafx.scene.control.Button = {
    final class $anon extends Button("Load") {
      def <init>(): <$anon: scalafx.scene.control.Button> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        var alert: GuiAlert = new GuiAlert();
        scala.Tuple2(enc, flagV) match {
          case scala.Tuple2("", _) => alert.showWarning("Please select encoding")
          case scala.Tuple2(_, "") => alert.showWarning("Please select variable")
          case scala.Tuple2(_, _) => {
            val loadingTask: scalafx.concurrent.Task[Unit] = createLoadingTask();
            loadingTask.setOnRunning(((x$3: javafx.concurrent.WorkerStateEvent) => {
              progressBar.progress = -1;
              completed.visible = false;
              loadingLabel.visible = true
            }));
            loadingTask.setOnSucceeded(((x$4: javafx.concurrent.WorkerStateEvent) => {
              progressBar.progress = 1;
              loadingLabel.visible = false;
              completed.visible = true;
              showCompletedMessage()
            }));
            new Thread(loadingTask).start()
          }
        }
      })
    };
    new $anon()
  };
  loadbtn.alignment = Center;
  private[this] val InputArea: scalafx.scene.control.TextArea = new TextArea();
  InputArea.prefHeight = 200;
  InputArea.prefWidth = 280;
  InputArea.promptText = "Insert the query or select the spec file with choose file option";
  InputArea.focused.onChange(input_text = InputArea.text.apply);
  private[this] var keylist: scala.collection.mutable.ListBuffer[String] = ListBuffer();
  private[this] var valuelist: scala.collection.mutable.ListBuffer[String] = ListBuffer();
  private[this] var deletekeylist: scala.collection.mutable.ListBuffer[String] = ListBuffer();
  private[this] var deletevaluelist: scala.collection.mutable.ListBuffer[String] = ListBuffer();
  private[this] var keyvalue: Map[String,String] = Map();
  private[this] var keyvarfree: List[String] = List();
  private[this] var valuevarfree: List[String] = List();
  ctx.withFilter(((check$ifrefutable$2: (String, Database.Schema)) => check$ifrefutable$2: @scala.unchecked match {
  case scala.Tuple2((k @ _), (v @ _)) => true
  case _ => false
})).foreach(((x$5: (String, Database.Schema)) => x$5: @scala.unchecked match {
    case scala.Tuple2((k @ _), (v @ _)) => {
      val st1: String = v.toString;
      val l: Int = st1.length;
      if (st1(l.-(1)).$eq$eq(';').$amp$amp(st1(l.-(2)).$eq$eq(';')).unary_$bang)
        {
          val k1: Array[String] = st1.split(';');
          if (k1.length.<=(2))
            {
              val c: Int = k1.length;
              1.to(c.-(1)).foreach(((i: Int) => keyvalue.$plus$eq(k.toString.$minus$greater(k1(i)))))
            }
          else
            if (k1.length.>=(3))
              1.to(k1.length.-(2)).foreach(((i: Int) => keyvalue.$plus$eq(k.toString.$minus$greater(k1(i)))))
            else
              ();
          if (k1.length.>=(3))
            {
              val k2: Array[String] = k1(k1.length.-(1)).split(',');
              k2.foreach(((j: String) => {
                keyvarfree = keyvarfree.$colon$plus(k.toString);
                valuevarfree = valuevarfree.$colon$plus(j)
              }))
            }
          else
            ()
        }
      else
        ()
    }
  }));
  private[this] val selectedMapping: scala.collection.mutable.HashMap[String,String] = HashMap.empty;
  private[this] val unselectedMapping: scala.collection.mutable.HashMap[String,String] = HashMap.empty;
  private[this] val selectedCheckboxes: scala.collection.mutable.ListBuffer[scalafx.scene.control.CheckBox] = ListBuffer.empty;
  private[this] val tab2vbox: scalafx.scene.layout.VBox = {
    final class $anon extends VBox {
      def <init>(): <$anon: scalafx.scene.layout.VBox> = {
        super.<init>();
        ()
      };
      spacing = 10;
      padding = geometry.Insets(0, 0, 0, 30);
      alignment = Center
    };
    new $anon()
  };
  tab2vbox.children.append({
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 20
    };
    new $anon()
  });
  tab2vbox.children.append({
    final class $anon extends Label("!! Do not select if the table has only one option !!") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      style = "-fx-font-weight: bold;"
    };
    new $anon()
  });
  tab2vbox.children.append({
    final class $anon extends Label("OR") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      style = "-fx-font-weight: bold;"
    };
    new $anon()
  });
  tab2vbox.children.append({
    final class $anon extends Label("!!Do not select all the options of two table together!!") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      style = "-fx-font-weight: bold;"
    };
    new $anon()
  });
  keyvalue.withFilter(((check$ifrefutable$3: (String, String)) => check$ifrefutable$3: @scala.unchecked match {
  case scala.Tuple2((key @ _), (values @ _)) => true
  case _ => false
})).foreach(((x$9: (String, String)) => x$9: @scala.unchecked match {
    case scala.Tuple2((key @ _), (values @ _)) => {
      val keyLabel: scalafx.scene.control.Label = new Label(key);
      val checkboxes: Array[scalafx.scene.control.CheckBox] = values.split(",").map(((value: String) => {
        val checkbox: scalafx.scene.control.CheckBox = {
          final class $anon extends CheckBox(value) {
            def <init>(): <$anon: scalafx.scene.control.CheckBox> = {
              super.<init>();
              ()
            };
            0.to(keyvarfree.length.$minus(1)).foreach(((c: Int) => if (key.==(keyvarfree(c)).$amp$amp(value.==(valuevarfree(c))))
              selected = true
            else
              ()))
          };
          new $anon()
        };
        checkbox.tooltip = new Tooltip("This checkbox can not be selected");
        checkbox
      }));
      checkboxes.foreach(((checkbox: scalafx.scene.control.CheckBox) => checkbox.selected.onChange(((x$6: scalafx.beans.value.ObservableValue[Boolean,Boolean], oldValue: Boolean, newValue: Boolean) => {
        val keyValues: Array[String] = keyvalue.getOrElse(key, "").split(",");
        if (newValue)
          {
            selectedCheckboxes.$plus$eq(checkbox);
            selectedMapping.update(key, selectedMapping.getOrElse(key, "").$plus(if (selectedMapping.get(key).exists(((x$7: String) => x$7.nonEmpty)))
  ","
else
  "").$plus(checkbox.text()));
            unselectedMapping.get(key).foreach(((values: String) => unselectedMapping.update(key, values.replace(checkbox.text(), ""))))
          }
        else
          {
            selectedCheckboxes.$minus$eq(checkbox);
            selectedMapping.get(key).foreach(((values: String) => selectedMapping.$plus$eq(key.$minus$greater(values.replace(checkbox.text(), "")))));
            unselectedMapping.update(key, unselectedMapping.getOrElse(key, "").$plus(if (unselectedMapping.get(key).exists(((x$8: String) => x$8.nonEmpty)))
  ","
else
  "").$plus(checkbox.text()))
          }
      }))));
      var checkboxesHBox: scalafx.scene.layout.VBox = {
        final class $anon extends VBox {
          def <init>(): <$anon: scalafx.scene.layout.VBox> = {
            super.<init>();
            ()
          };
          spacing = 10;
          children = checkboxes
        };
        new $anon()
      };
      var keyVBox: scalafx.scene.layout.VBox = {
        final class $anon extends VBox {
          def <init>(): <$anon: scalafx.scene.layout.VBox> = {
            super.<init>();
            ()
          };
          spacing = 5;
          children = Seq(keyLabel, checkboxesHBox)
        };
        new $anon()
      };
      tab2vbox.children.append(keyVBox)
    }
  }));
  private def createupdatingTask(): scalafx.concurrent.Task[Unit] = Task({
    selectedMapping.withFilter(((check$ifrefutable$4: (String, String)) => check$ifrefutable$4: @scala.unchecked match {
  case scala.Tuple2((key @ _), (values @ _)) => true
  case _ => false
})).foreach(((x$10: (String, String)) => x$10: @scala.unchecked match {
      case scala.Tuple2((key @ _), (values @ _)) => {
        val valueList: Array[String] = values.split(",");
        valueList.foreach(((value: String) => st.executeUpdate("UPDATE schema SET varfree = TRUE WHERE tablename=\'".+(key).+("\'and fieldname=\'").+(value).+("\';"))))
      }
    }));
    unselectedMapping.withFilter(((check$ifrefutable$5: (String, String)) => check$ifrefutable$5: @scala.unchecked match {
  case scala.Tuple2((key @ _), (values @ _)) => true
  case _ => false
})).foreach(((x$11: (String, String)) => x$11: @scala.unchecked match {
      case scala.Tuple2((key @ _), (values @ _)) => {
        val valueList: Array[String] = values.split(",");
        valueList.foreach(((value: String) => st.executeUpdate("UPDATE schema SET varfree = FALSE WHERE tablename=\'".+(key).+("\'and fieldname=\'").+(value).+("\';"))))
      }
    }));
    Thread.sleep(10000)
  });
  private[this] val progressBar2: scalafx.scene.control.ProgressBar = {
    final class $anon extends ProgressBar {
      def <init>(): <$anon: scalafx.scene.control.ProgressBar> = {
        super.<init>();
        ()
      };
      prefWidth = 200
    };
    new $anon()
  };
  private[this] val loadingLabel2: scalafx.scene.control.Label = {
    final class $anon extends Label("Updating...") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      visible = false
    };
    new $anon()
  };
  private[this] val completed2: scalafx.scene.control.Label = {
    final class $anon extends Label("Updating Complete!!") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      visible = false
    };
    new $anon()
  };
  private[this] val tab2hbox2: scalafx.scene.layout.HBox = {
    final class $anon extends HBox {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      spacing = 20;
      alignment = Center;
      children = Seq(loadingLabel2, completed2)
    };
    new $anon()
  };
  private[this] val up_schema: scalafx.scene.control.Button = {
    final class $anon extends Button("Update Schema") {
      def <init>(): <$anon: scalafx.scene.control.Button> = {
        super.<init>();
        ()
      };
      onAction = ((e: ActionEvent) => {
        print("SM".+(selectedMapping).$plus("\n"));
        print(unselectedMapping);
        val loadingTask: scalafx.concurrent.Task[Unit] = createupdatingTask();
        loadingTask.setOnRunning(((x$12: javafx.concurrent.WorkerStateEvent) => {
          progressBar2.progress = -1;
          completed2.visible = false;
          loadingLabel2.visible = true
        }));
        loadingTask.setOnSucceeded(((x$13: javafx.concurrent.WorkerStateEvent) => {
          progressBar2.progress = 1;
          loadingLabel2.visible = false;
          completed2.visible = true
        }));
        new Thread(loadingTask).start()
      })
    };
    new $anon()
  };
  private[this] val hnewbox: scalafx.scene.layout.HBox = {
    final class $anon extends HBox() {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      children = Seq(up_schema)
    };
    new $anon()
  };
  private[this] val hnewbox1: scalafx.scene.layout.HBox = {
    final class $anon extends HBox() {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      children = Seq(loadingLabel2, completed2)
    };
    new $anon()
  };
  hnewbox.alignment = Center;
  tab2vbox.children.add(progressBar2);
  tab2vbox.children.add(hnewbox1);
  tab2vbox.children.add(hnewbox);
  private[this] var filelabel: scalafx.scene.control.Label = {
    final class $anon extends Label("File Name") {
      def <init>(): <$anon: scalafx.scene.control.Label> = {
        super.<init>();
        ()
      };
      layoutX = 150;
      layoutY = 510
    };
    new $anon()
  };
  private[this] val file: scalafx.scene.control.Button = {
    final class $anon extends Button("Choose File") {
      def <init>(): <$anon: scalafx.scene.control.Button> = {
        super.<init>();
        ()
      };
      layoutX = 150;
      layoutY = 490;
      onAction = ((e: ActionEvent) => {
        val filechooser: scalafx.stage.FileChooser = new FileChooser();
        val selectedfile: java.io.File = filechooser.showOpenDialog(stage);
        input_text = selectedfile.toString();
        val filename: Array[String] = input_text.split('\\');
        filelabel.text = filename(filename.length.-(1)).capitalize
      })
    };
    new $anon()
  };
  file.alignment = Center;
  private[this] val rbn5: scalafx.scene.control.Button = {
    final class $anon extends Button("RUN") {
      def <init>(): <$anon: scalafx.scene.control.Button> = {
        super.<init>();
        ()
      };
      layoutX = 210;
      layoutY = 490;
      onAction = ((e: ActionEvent) => {
        var alert: GuiAlert = new GuiAlert();
        scala.Tuple5(enc, flagV, flag_null, flag_error, input_text) match {
          case scala.Tuple5("", _, _, _, _) => alert.showWarning("Please select encoding")
          case scala.Tuple5(_, "", _, _, _) => alert.showWarning("Please select variable")
          case scala.Tuple5(_, _, "", _, _) => alert.showWarning("Please select NULL options")
          case scala.Tuple5(_, _, _, "", _) => alert.showWarning("Please select Cost Function")
          case scala.Tuple5(_, _, _, _, "") => alert.showWarning("Please insert input")
          case scala.Tuple5(_, _, _, _, _) => {
            val result: scalafx.scene.control.ButtonType = alert.showalert();
            if (result.==(ButtonType.Yes))
              {
                stage.scene = GuiScene2.createScene(connector, input_text, ctx1, enc, encoding, flag_error, flag_null.toBoolean, (() => stage.setScene(scene1)));
                stage.show()
              }
            else
              ()
          }
        }
      })
    };
    new $anon()
  };
  private[this] val tab4vbox: scalafx.scene.layout.VBox = {
    final class $anon extends VBox() {
      def <init>(): <$anon: scalafx.scene.layout.VBox> = {
        super.<init>();
        ()
      };
      spacing = 10;
      padding = geometry.Insets(0, 0, 0, 20)
    };
    new $anon()
  };
  private[this] val tab4lbl: scalafx.scene.control.Label = new Label(" Please change the config.txt file according to your database information \n".+("If you are running this for the first time Load the data in Tab 1 before pressing the Run Button \n"));
  private[this] val tab4lbl1: scalafx.scene.control.Label = new Label("In your query you can apply this operations: Select (U+03c3), Project (π), ProjectAway (π), Join (⨝), Renaming (U+03C1), Difference (\'\'), Aggregation (U+03b3),".+("UNION (∪), DUNION  (⊎), Coalescing (к) \n"));
  private[this] val rbn6: scalafx.scene.control.Button = {
    final class $anon extends Button("EXIT") {
      def <init>(): <$anon: scalafx.scene.control.Button> = {
        super.<init>();
        ()
      };
      layoutX = 260;
      layoutY = 490;
      onAction = ((e: ActionEvent) => sys.exit(0))
    };
    new $anon()
  };
  private[this] var tab1vbox: scalafx.scene.layout.VBox = {
    final class $anon extends VBox() {
      def <init>(): <$anon: scalafx.scene.layout.VBox> = {
        super.<init>();
        ()
      };
      padding = geometry.Insets(0, 0, 0, 80)
    };
    new $anon()
  };
  tab1vbox.children = List({
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 30
    };
    new $anon()
  }, label, rbn1, rbn2, {
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 10
    };
    new $anon()
  }, label1, rbn3, rbn4, {
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 10
    };
    new $anon()
  }, label2, rbn_null, rbn_not_null, {
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 10
    };
    new $anon()
  }, label3, rbn_s_error, rbn_a_error, rbn_value_interval, {
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 10
    };
    new $anon()
  }, progressBar, tab1hbox, loadbtn);
  private[this] val tab2scroll: javafx.scene.control.ScrollPane = new ScrollPane();
  tab2scroll.content = tab2vbox;
  private[this] val tab3hbox: scalafx.scene.layout.HBox = {
    final class $anon extends HBox() {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      spacing = 10;
      alignment = Center
    };
    new $anon()
  };
  tab3hbox.children = List(InputArea);
  private[this] val tab3hbox1: scalafx.scene.layout.HBox = {
    final class $anon extends HBox() {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      spacing = 10;
      alignment = Center
    };
    new $anon()
  };
  tab3hbox1.children = List(file, filelabel);
  private[this] val tab3hbox2: scalafx.scene.layout.HBox = {
    final class $anon extends HBox() {
      def <init>(): <$anon: scalafx.scene.layout.HBox> = {
        super.<init>();
        ()
      };
      spacing = 10;
      alignment = Center
    };
    new $anon()
  };
  tab3hbox2.children = List(rbn5, rbn6);
  private[this] var tab3vbox: scalafx.scene.layout.VBox = {
    final class $anon extends VBox() {
      def <init>(): <$anon: scalafx.scene.layout.VBox> = {
        super.<init>();
        ()
      };
      spacing = 10
    };
    new $anon()
  };
  tab3vbox.children = List({
    final class $anon extends Pane {
      def <init>(): <$anon: scalafx.scene.layout.Pane> = {
        super.<init>();
        ()
      };
      prefHeight = 10
    };
    new $anon()
  }, tab3hbox, tab3hbox1, tab3hbox2);
  private[this] val tab4scroll: javafx.scene.control.ScrollPane = new ScrollPane();
  tab4scroll.content = tab4vbox;
  tab1.content = tab1vbox;
  tab2.content = tab2scroll;
  tab3.content = tab3vbox;
  tab4.content = tab4scroll;
  tabpane.tabs = tabs;
  tabpane.selectionModel().selectedItem.onChange(((x$14: scalafx.beans.value.ObservableValue[javafx.scene.control.Tab,javafx.scene.control.Tab], x$15: javafx.scene.control.Tab, newTab: javafx.scene.control.Tab) => {
    val currentIndex: Int = tabpane.selectionModel().getSelectedIndex;
    val expectedNextIndex: Int = if (currentIndex.<(tabs.size.$minus(1)))
      currentIndex.+(1)
    else
      0;
    if (newTab.!=(tabs(expectedNextIndex)))
      tabpane.selectionModel().select(currentIndex)
    else
      ()
  }));
  root = tabpane
}
     while compiling: file:///D:/PISTIS/Eris-main/GuiNew.scala
        during phase: globalPhase=<no phase>, enteringPhase=parser
     library version: version 2.13.10
    compiler version: version 2.13.10
  reconstructed args: -classpath <WORKSPACE>\.bloop\eris-main\bloop-bsp-clients-classes\classes-Metals-o3OplTIZRm2ZTUesEcn5aw==;<HOME>\AppData\Local\bloop\cache\semanticdb\com.sourcegraph.semanticdb-javac.0.8.24\semanticdb-javac-0.8.24.jar;<WORKSPACE>\lib\ojdbc5.jar;<WORKSPACE>\lib\postgresql-42.3.1.jar;<WORKSPACE>\lib\scala-parser-combinators_2.13-2.3.0.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.10\scala-library-2.13.10.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-json_2.13\2.9.4\play-json_2.13-2.9.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scalafx\scalafx_2.13\19.0.0-R30\scalafx_2.13-19.0.0-R30.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\19\javafx-base-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\19\javafx-controls-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-fxml\19\javafx-fxml-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\19\javafx-graphics-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\19\javafx-media-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-swing\19\javafx-swing-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-web\19\javafx-web-19-win.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\typesafe\play\play-functional_2.13\2.9.4\play-functional_2.13-2.9.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.10\scala-reflect-2.13.10.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-core\2.11.4\jackson-core-2.11.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-annotations\2.11.4\jackson-annotations-2.11.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.11.4\jackson-datatype-jdk8-2.11.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.11.4\jackson-datatype-jsr310-2.11.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\com\fasterxml\jackson\core\jackson-databind\2.11.4\jackson-databind-2.11.4.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-base\19\javafx-base-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-controls\19\javafx-controls-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-fxml\19\javafx-fxml-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-graphics\19\javafx-graphics-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-media\19\javafx-media-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-swing\19\javafx-swing-19.jar;<HOME>\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\openjfx\javafx-web\19\javafx-web-19.jar -Xplugin-require:semanticdb -Yrangepos -Ymacro-expand:discard -Ycache-plugin-class-loader:last-modified -Ypresentation-any-thread

  last tree to typer: Template(value <local $anon>)
       tree position: line 41 of file:///D:/PISTIS/Eris-main/GuiNew.scala
              symbol: value <local $anon>
   symbol definition: val <local $anon>: <notype> (a TermSymbol)
      symbol package: <empty>
       symbol owners: value <local $anon> -> <$anon: scalafx.scene.Scene> -> value <local GuiNew> -> object GuiNew
           call site: <none> in <none>

== Source file context for tree position ==

    38     title.value = "Eris: Discord measurement prototype"
    39   }
    40 
    41   scene1 = new Scene(400, 450) {
    42 
    43     // var input_text: String = " "
    44 
occurred in the presentation compiler.

action parameters:
offset: 18814
uri: file:///D:/PISTIS/Eris-main/GuiNew.scala
text:
import scala.util.control.Breaks._
import com.sun.glass.ui.Application
import javafx.scene.control.ScrollPane
import scalafx.Includes._
import scalafx.application
import scalafx.application.{AppHelper, JFXApp}
import scalafx.scene.Scene
import scalafx.scene.control._
import scalafx.event.ActionEvent
import scalafx.geometry.Orientation
import scalafx.geometry.Orientation.Horizontal
import scalafx.geometry.Pos.Center
import scalafx.scene.layout.Priority.Always
import scalafx.scene.layout.TilePane.getAlignment
import scalafx.scene.layout._
import scalafx.stage.{FileChooser, Window}
import scalafx.stage.FileChooser
import scala.collection.mutable.ListBuffer
import scalafx.concurrent.Task
import scala.io.Source
import scalafx.geometry.HPos
import java.awt.Insets
import scalafx.geometry
import scala.collection.mutable.HashMap
import scalafx.scene.text.FontWeight

object GuiNew extends JFXApp {
  var scene1: Scene = null
  var scene2: Scene = null
  var input_text: String = ""
  var flagV: String = ""
  var enc: String = ""
  var flag_null: String = ""
  var flag_error: String = ""
  var encoding: Encoding = _

  stage = new JFXApp.PrimaryStage {
    title.value = "Eris: Discord measurement prototype"
  }

  scene1 = new Scene(400, 450) {

    // var input_text: String = " "

    // reading the configuration file for user credentials i.e database info
    var userConfig = Array[String]()
    var connectionProfile = Source.fromFile("config.txt")
    for (line <- connectionProfile.getLines) {
      userConfig = userConfig :+ line.toString()
    }
    connectionProfile.close

    var connector =
      Connector(userConfig(0), userConfig(1), userConfig(2), userConfig(3))
    var conn = connector.getConnection()

    var st = conn.createStatement()
    var ctx = Database.loadSchema_for_gui(conn)
    var ctx1 = Database.loadSchema(conn) // keeps all the key values
    // print("ctx" + ctx + "\n")
    // print("ctx1" + ctx1)

    val tabpane = new TabPane()
    val tab1 = new Tab()
    tab1.text = "General"
    val tab2 = new Tab()
    tab2.text = "Grund Truth"
    val tab3 = new Tab()
    tab3.text = "Query Input"
    val tab4 = new Tab()
    tab4.text = "Help"
    val tabs = IndexedSeq(tab1.delegate, tab2.delegate, tab3.delegate, tab4.delegate)

    ////////// Tab 1 /////////////
    val label = new Label("Which Encoding would you prefer?")
    val rbn1 = new RadioButton("NF2_SparseV") {
      onAction = (e: ActionEvent) => {
        enc = "nf2_sparsev"
        encoding = Encoding.encoder_to_use(enc)
      }
    }
    val rbn2 = new RadioButton("Partitioning") {
      onAction = (e: ActionEvent) => {
        enc = "partitioning"
        encoding = Encoding.encoder_to_use(enc)
      }
    }

    val toggol1 = new ToggleGroup
    toggol1.toggles = List(rbn1, rbn2)

    val label1 = new Label("Variable Generation") {}
    val rbn3 = new RadioButton("V+X") {
      onAction = (e: ActionEvent) => {
        flagV = "true"
      }
    }
    val rbn4 = new RadioButton("V.(1+X)") {
      onAction = (e: ActionEvent) => {
        flagV = "false"
      }
    }
    val toggol2 = new ToggleGroup
    toggol2.toggles = List(rbn3, rbn4)
    val label2 = new Label("Do you want to consider NULL in cost function?") {}
    val rbn_null = new RadioButton("Yes") {
      onAction = (e: ActionEvent) => {
        flag_null = "true"
      }
    }
    val rbn_not_null = new RadioButton("No") {
      onAction = (e: ActionEvent) => {
        flag_null = "false"
      }
    }
    val toggol3 = new ToggleGroup
    toggol3.toggles = List(rbn_null, rbn_not_null)
    val label3 = new Label("Cost functions") {}

    val rbn_s_error = new RadioButton("Average Square Error (ASE)") {
      onAction = (e: ActionEvent) => {
        flag_error = "ASE"
        print(flag_error)
      }
    }
    val rbn_a_error = new RadioButton("Average Absolute Error (AAE)") {
      onAction = (e: ActionEvent) => {
        flag_error = "AAE"
        print(flag_error)
      }
    }
    val rbn_value_interval = new RadioButton("Error with Variable Constraints"){
      onAction = (e: ActionEvent) => {
        flag_error = "Value_Interval"
        print(flag_error)
      }
    }
    val toggol4 = new ToggleGroup
    toggol4.toggles = List(rbn_s_error, rbn_a_error,rbn_value_interval)

    ////// Loading Tasks ///////
    def createLoadingTask(): Task[Unit] = Task {
      // Simulating a time-consuming process
      for ((k, v) <- ctx1) {
        // print(k)
        Loader.load(
          connector,
          k.toLowerCase(),
          encoding,
          false,
          flagV.toBoolean
        )
      }
      Thread.sleep(10000)
    }

    def showCompletedMessage(): Label = {
      val com = new Label("Completed!")
      com
    }
    val progressBar = new ProgressBar {
      prefWidth = 200
    }

    val loadingLabel = new Label("Loading...") {
      visible = false
    }
    val completed = new Label("Completed!!") {
      visible = false
    }
    val tab1hbox = new HBox {
      spacing = 20
      children = Seq(loadingLabel, completed)
    }

    val loadbtn = new Button("Load") {
      onAction = (e: ActionEvent) => {
        var alert = new GuiAlert()
        (enc, flagV) match {
          case ("", _) => alert.showWarning("Please select encoding")
          case (_, "") => alert.showWarning("Please select variable")
          case (_, _) => {
            val loadingTask = createLoadingTask()

            loadingTask.setOnRunning { _ =>
              progressBar.progress = -1 // Indeterminate progress
              completed.visible = false
              loadingLabel.visible = true

            }

            loadingTask.setOnSucceeded { _ =>
              progressBar.progress = 1 // Completed progress
              // loadingLabel.text = "Completed!!"
              loadingLabel.visible = false
              completed.visible = true
              showCompletedMessage()
            }

            new Thread(loadingTask).start()
          }
        }

      }
    }

    loadbtn.alignment = Center

    ////////// Tab 3 /////////////
    val InputArea = new TextArea
    InputArea.prefHeight = 200
    InputArea.prefWidth = 280
    InputArea.promptText =
      "Insert the query or select the spec file with choose file option"
    // InputArea.promptText = "Example"
    InputArea.focused.onChange {
      input_text = InputArea.text.apply
      // println(input_text)
    }

    ////////// Tab 2 /////////////
    // var tab2vbox = new VBox(){
    //   padding = geometry.Insets(0,0,0,30)
    //   spacing = 10
    //   alignment = Center
    // }
    // tab2vbox.children.add(new Pane{prefHeight = 10})
    var keylist: ListBuffer[String] = ListBuffer()
    var valuelist: ListBuffer[String] = ListBuffer()
    var deletekeylist: ListBuffer[String] = ListBuffer()
    var deletevaluelist: ListBuffer[String] = ListBuffer()
    var keyvalue: Map[String, String] = Map()
    var keyvarfree: List[String] = List()
    var valuevarfree: List[String] = List()

    // extracted values to create the tablename and attribute name

    for ((k, v) <- ctx) {

      val st1 = v.toString
      val l = st1.length

      if (!(st1(l - 1) == ';' && st1(l - 2) == ';')) {
        val k1 = st1.split(';')
        if (k1.length <= 2) {
          val c = k1.length
          for (i <- 1 to c - 1) {
            keyvalue += (k.toString -> k1(i))
          }
        } else {
          if (k1.length >= 3) {
            for (i <- 1 to k1.length - 2) {
              keyvalue += (k.toString -> k1(i))
            }
          }
        }
        if (k1.length >= 3) {
          val k2 = k1(k1.length - 1).split(',')
          for (j <- k2) {
            keyvarfree = keyvarfree :+ k.toString
            valuevarfree = valuevarfree :+ j
          }
        }

      }

    }
    // print(keyvalue)

    val selectedMapping: HashMap[String, String] = HashMap.empty
    val unselectedMapping: HashMap[String, String] = HashMap.empty

    val selectedCheckboxes: ListBuffer[CheckBox] = ListBuffer.empty

    val tab2vbox = new VBox {
      spacing = 10
      padding = geometry.Insets(0, 0, 0, 30)
      alignment = Center
    }
    tab2vbox.children.append(new Pane { prefHeight = 20 })

    tab2vbox.children.append(
      new Label("!! Do not select if the table has only one option !!") {
        style = "-fx-font-weight: bold;"
      }
    )
    tab2vbox.children.append(new Label("OR") {
      style = "-fx-font-weight: bold;"
    })
    tab2vbox.children.append(
      new Label("!!Do not select all the options of two table together!!") {
        style = "-fx-font-weight: bold;"
      }
    )
    for ((key, values) <- keyvalue) {
      val keyLabel = new Label(key)
      val checkboxes = values.split(",").map { value =>
        val checkbox = new CheckBox(value) {
          for (c <- 0 to keyvarfree.length - 1) {
            if (key == keyvarfree(c) && value == valuevarfree(c)) {
              selected = true
              // selectedMapping += (key -> (selectedMapping.getOrElse(key, "") + checkbox.text()))
            }
          }
        }
        checkbox.tooltip = new Tooltip("This checkbox can not be selected")
        checkbox
      }
      checkboxes.foreach { checkbox =>
        checkbox.selected.onChange { (_, oldValue, newValue) =>
          val keyValues = keyvalue.getOrElse(key, "").split(",")
          if (newValue) {
            selectedCheckboxes += checkbox
            selectedMapping.update(
              key,
              selectedMapping.getOrElse(key, "") + (if (
                                                      selectedMapping
                                                        .get(key)
                                                        .exists(_.nonEmpty)
                                                    ) ","
                                                    else "") + checkbox.text()
            )
            unselectedMapping.get(key).foreach { values =>
              unselectedMapping.update(key, values.replace(checkbox.text(), ""))
            }

            // selectedCheckboxes += checkbox
            // selectedMapping += (key -> (selectedMapping.getOrElse(key, "") + checkbox.text()))
            // unselectedMapping.get(key).foreach { values =>
            //   unselectedMapping += (key -> values.replace(checkbox.text(), ""))
            // }
          } else {
            selectedCheckboxes -= checkbox
            selectedMapping.get(key).foreach { values =>
              selectedMapping += (key -> values.replace(checkbox.text(), ""))
            }

            unselectedMapping.update(
              key,
              unselectedMapping.getOrElse(key, "") + (if (
                                                        unselectedMapping
                                                          .get(key)
                                                          .exists(_.nonEmpty)
                                                      ) ","
                                                      else "") + checkbox.text()
            )

          }
        }
      }
      var checkboxesHBox = new VBox {
        spacing = 10
        children = checkboxes
      }
      var keyVBox = new VBox {
        spacing = 5
        children = Seq(keyLabel, checkboxesHBox)
      }
      tab2vbox.children.append(keyVBox)
    }

    ////////////// Updating Schema //////////////

    def createupdatingTask(): Task[Unit] = Task {
      // Simulating a time-consuming process
      for ((key, values) <- selectedMapping) {
        val valueList = values.split(",")
        for (value <- valueList) {
          st.executeUpdate(
            "UPDATE schema SET varfree = TRUE WHERE tablename='" + key + "'and fieldname='" + value + "';"
          )
          // print("keylist" + keylist +"\n")
          // print("valuelist" + valuelist+"\n")
        }
      }
      // print(deletekeylist.length)
      // print(deletevaluelist.length)

      for ((key, values) <- unselectedMapping) {
        val valueList = values.split(",")
        for (value <- valueList) {
          st.executeUpdate(
            "UPDATE schema SET varfree = FALSE WHERE tablename='" + key + "'and fieldname='" + value + "';"
          )
        }
        // print("deletekeylist" + deletekeylist+"\n")
        // print("deletevaluelist" + deletevaluelist+"\n")

      }
      Thread.sleep(10000)
    }

    val progressBar2 = new ProgressBar {
      prefWidth = 200
    }

    val loadingLabel2 = new Label("Updating...") {
      visible = false
    }
    val completed2 = new Label("Updating Complete!!") {
      visible = false
    }
    val tab2hbox2 = new HBox {
      spacing = 20
      alignment = Center
      children = Seq(loadingLabel2, completed2)
    }

    val up_schema = new Button("Update Schema") {
      onAction = (e: ActionEvent) => {
        print("SM" + selectedMapping + "\n")
        print(unselectedMapping)
        val loadingTask = createupdatingTask()

        loadingTask.setOnRunning { _ =>
          progressBar2.progress = -1 // Indeterminate progress
          completed2.visible = false
          loadingLabel2.visible = true

        }

        loadingTask.setOnSucceeded { _ =>
          progressBar2.progress = 1 // Completed progress
          // loadingLabel.text = "Completed!!"
          loadingLabel2.visible = false
          completed2.visible = true
        }

        new Thread(loadingTask).start()
      }
    }

    ////////// Tab 2 /////////////
    val hnewbox = new HBox() {
      children = Seq(up_schema)
    }

    val hnewbox1 = new HBox() {
      children = Seq(loadingLabel2, completed2)
    }
    // hnewbox.children.add(up_schema)
    // hnewbox.children.add(reset_schema)
    hnewbox.alignment = Center
    tab2vbox.children.add(progressBar2)
    tab2vbox.children.add(hnewbox1)
    tab2vbox.children.add(hnewbox)

    //////// Tab 3/////////////
    var filelabel = new Label("File Name") {
      layoutX = 150
      layoutY = 510
    }

    // to add filechooser
    val file = new Button("Choose File") {
      layoutX = 150
      layoutY = 490
      onAction = (e: ActionEvent) => {
        val filechooser = new FileChooser
        val selectedfile = filechooser.showOpenDialog(stage)
        input_text = selectedfile.toString()
        val filename = input_text.split('\\')
        filelabel.text = filename(filename.length - 1).capitalize
        // print(input_text)
      }
    }
    file.alignment = Center

    val rbn5 = new Button("RUN") {
      layoutX = 210
      layoutY = 490
      onAction = (e: ActionEvent) => {
        // TO DO
        // need to made loading automatic
        // var new_scene_obj = new GuiNewScene()

        var alert = new GuiAlert()
        (enc, flagV, flag_null, flag_error, input_text) match {
          case ("", _, _, _, _) => alert.showWarning("Please select encoding")
          case (_, "", _, _, _) => alert.showWarning("Please select variable")
          case (_, _, "", _, _) =>
            alert.showWarning("Please select NULL options")
          case (_, _, _, "", _) =>
            alert.showWarning("Please select Cost Function")
          case (_, _, _, _, "") => alert.showWarning("Please insert input")
          case (_, _, _, _, _) => {
            val result = alert.showalert()
            if (result == ButtonType.Yes) {
              stage.scene = GuiScene2.createScene(
                connector,
                input_text,
                ctx1,
                enc,
                encoding,
                flag_error,
                flag_null.toBoolean,
                () => stage.setScene(scene1)
              )
              stage.show()
              // stage.close()
              // stage.scene = scene1
            }
          }
        }
      }
    }
    /////// TAB 4 ////////
    val tab4vbox = new VBox(){
      spacing = 10
      padding = geometry.Insets(0,0,0,20)
      // alignment = Center
    }
    val tab4lbl = new Label(" Please change the config.txt file according to your database information \n" +
      "If you are running this for the first time Load the data in Tab 1 before pressing the Run Button \n")
    val tab4lbl1 = new Label("In your query you can apply this operations: Select (U+03c3), Project (π), ProjectAway (π), Join (⨝), Renaming (U+03C1), Difference ('\'), Aggregation (U+03b3)," +
"UNION (∪), DUNION  (⊎), Coalescing (к) \n")

    // tab4vbox.children = List(tab4lbl, tab4lbl1)

    val rbn6 = new Button("EXIT") {
      layoutX = 260
      layoutY = 490
      onAction = (e: ActionEvent) => sys.exit(0)

    }

    //////   Tab1  ///////////
    var tab1vbox = new VBox() {
      padding = geometry.Insets(0, 0, 0, 80)
      // spacing = 10
    }

    // tab1vbox.alignment = Center
    tab1vbox.children = List(
      new Pane { prefHeight = 30 },
      label,
      rbn1,
      rbn2,
      new Pane { prefHeight = 10 },
      label1,
      rbn3,
      rbn4,
      new Pane { prefHeight = 10 },
      label2,
      rbn_null,
      rbn_not_null,
      new Pane { prefHeight = 10 },
      label3,
      rbn_s_error,
      rbn_a_error,
      rbn_value_interval,
      new Pane { prefHeight = 10 },
      progressBar,
      tab1hbox,
      loadbtn
    )

    ////////// Tab 2 /////////////
    val tab2scroll = new ScrollPane()
    tab2scroll.content = tab2vbox
    ////////// Tab 3 /////////////
    val tab3hbox = new HBox() {
      spacing = 10
      alignment = Center
    }
    tab3hbox.children = List(InputArea)
    val tab3hbox1 = new HBox() {
      spacing = 10
      alignment = Center
    }
    tab3hbox1.children = List(file, filelabel)

    val tab3hbox2 = new HBox() {
      spacing = 10
      alignment = Center
    }
    tab3hbox2.children = List(rbn5, rbn6)

    var tab3vbox = new VBox() {
      spacing = 10
      // padding = Insets(10)
    }
    tab3vbox.children =
      List(new Pane { prefHeight = 10 }, tab3hbox, tab3hbox1, tab3hbox2)

    //// Tab 4 /////
    val tab4scroll = new ScrollPane()
    tab4scroll.content = tab4vbox


    ///////// TABPANE/////////
    tab1.content = tab1vbox
    tab2.content = tab2scroll
    tab3.content = tab3vbox
    tab4.content = tab4scroll
    tabpane.tabs = tabs
    ////////  To crea@@te the TAB order /////
    tabpane.selectionModel().selectedItem.onChange { (_, _, newTab) =>
    val currentIndex = tabpane.selectionModel().getSelectedIndex
    val expectedNextIndex = if (currentIndex < tabs.size - 1) currentIndex + 1 else 0
      if (newTab != tabs(expectedNextIndex)) {
    tabpane.selectionModel().select(currentIndex)
  }
}
    root = tabpane
  }

  stage.scene = scene1
}



error stacktrace:
scala.reflect.internal.Reporting.abort(Reporting.scala:69)
	scala.reflect.internal.Reporting.abort$(Reporting.scala:65)
	scala.reflect.internal.SymbolTable.abort(SymbolTable.scala:28)
	scala.tools.nsc.typechecker.Typers$Typer.typedOutsidePatternMode$1(Typers.scala:5984)
	scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:6001)
	scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:6047)
	scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:6145)
	scala.meta.internal.pc.PcDefinitionProvider.definitionTypedTreeAt(PcDefinitionProvider.scala:160)
	scala.meta.internal.pc.PcDefinitionProvider.definition(PcDefinitionProvider.scala:68)
	scala.meta.internal.pc.PcDefinitionProvider.definition(PcDefinitionProvider.scala:16)
	scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$definition$1(ScalaPresentationCompiler.scala:315)
